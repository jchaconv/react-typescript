
************************************************************
React + TypeScript: Crear aplicación de React con Typescript
************************************************************

Configuraciones iniciales:

npx create-react-app mi-app --template typescript
npm start

Borrar:
-App.css
-App.test.tsx
-index.css
-logo.svg
-reportWebVitals.d.ts

Dejar muy simple:
-App.tsx
-index.tsx

Modificar:
index.html
→ Añadir bootstrap con <link ref.../>
→ Añadir clases <body class="container bg-dark text-white">

*****************************
React + TypeScript: useState
*****************************

Ejemplo del Counter:


Crear:
-/src/components/Counter.tsx

Modificar:
- App.tsx → Importar Counter

Tipado:

tsconfig.json tiene la propiedad "strict":true,
esto no nos permite dejar como any los parámetros

const [counter, setCounter] = useState(0);
Al ponerle valor inicial 0 el useState pasa a tener este tipado → useState<number>
el rombo <> indica un genérico, en este caso contiene number porque reconoció lo que puse

Para indicar que la función no retorna nada:
const incrementar = ():void => {
    setCounter( counter + 1);
}

Se especifica que reciba el numero de tipo number y por defecto sea 1

const incrementar = ( numero: number = 1 ):void => {
    setCounter( counter + numero );
}

Sin embargo, se tiene que llamar de esta manera a la función para que evite
mandarle el evento y le pase el número . Si se deja vacío toma valor 1
<button
    onClick={ () => incrementar(2) }
    className='btn btn-outline-primary mt-2'
>

Para un reset se hizo con el setCounter de esta manera:
<button
    onClick={ () => setCounter(0) }
    className='btn btn-outline-danger mt-2'
>


***********************

Ejemplo del User:


Crear:
-/src/components/Usuario.tsx

Se crea la interfaz para usarla en el tipado:

interface User {
    uid: string;
    name: string;
}

Aquí defino que useState será de tipo User:

const [user, setUser] = useState<User>();

Cuando uso el setUser con los valores como aparecen aquí ya no marca error y los reconoce bien:

const login = () => {
    setUser({
        uid: 'ABC1213',
        name: 'Julio Chacon'
    });
}

Si se quiere poner valores por defecto al useState se puede hacer así,
satisfaciendo la estructura de la interfaz que definimos:

const [user, setUser] = useState<User>({
    uid: '',
    name: ''
});

A partir de lo que tenemos se puede hacer algo más dinámico para mostrar algo si no hay usuario:
{
    (!user)
        ? <pre className="mt-2">No hay usuario</pre>
        : <pre className="mt-2">{ JSON.stringify( user )}</pre>
}


También se puede crear un objeto del tipo de la interfaz

const tempUser: User = {
    uid: 'Qwertty',
    name: 'TempUser'
}

Y lo podemos establecer como initialState en el useState:

const [user, setUser] = useState<User>(tempUser);



******************************************************
React + TypeScript: useEffect + useRef + Custom Props
******************************************************

Se usa así para sumar los segundos:
setSegundos( s => s + 1 )

useEffect → Cuando cambia el estado de la dependencia se dispara el callback

Crear:
-/src/components/TimerPadre.tsx
-/src/components/Timer.tsx

Para recibir como argumento en el componente se usó type de esta manera:

type TimerArgs = {
    milisegundos: number,
    segundos?: number, //lleva ? para indicar que es opcional
}

export const Timer = ( args: TimerArgs ) => {
    ...
} 

Al desestructurar se ve así:

export const Timer = ( {milisegundos}: TimerArgs ) => {
    ...
}    

Y al enviarle desde el TimerPadre se ve así y no marca error:

<Timer milisegundos={ milisegundos } />


Se usó el ejemplo de interval, cuando se puso la dependencia de milisegundos
se acumulaban los interval y eso hacía que se ejecute más rápido el timer.

Por eso es necesario hacer la limpieza del interval cuando el componente se destruye
Al pasar el cursor por setInterval() se ve que el retorno es NodeJS.Timer

useRef → Crea referencia de un valor en memoria sin importar cuantas veces se reconstruya el componente

Con esto tengo la referencia al interval para limpiarlo(con clearInterval() de js) cuando cambie los milisegundos, por eso llamo a ref.current

const ref = useRef<NodeJS.Timer>();












